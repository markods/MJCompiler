// ________________________________________________________________________________________________
// import section
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


// ________________________________________________________________________________________________
// directive section
parser code {:
	protected static Logger logger = Logger.getLogger( MJParser.class );
	private boolean errorDetected = false;


    // check if there are parse errors
    public boolean hasErrors() { return errorDetected; }


    // redefine cup parser methods for error reporting
    public void unrecovered_syntax_error( Symbol cur_token ) throws java.lang.Exception
    {
        report_fatal_error( "Fatal error, parsing stopped", cur_token );
    }

    // redefine cup parser methods for error reporting
    public void syntax_error( Symbol cur_token )
    {
        report_error( "Syntax error", cur_token );
    }

    // redefine cup parser methods for error reporting
    public void report_fatal_error( String message, Object info ) throws java.lang.Exception
    {
        done_parsing();
        report_error( message, info );
    }

    // redefine cup parser methods for error reporting
    public void report_error( String message, Object info )
    {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder( message );

    	if( info instanceof Symbol )
        {
            msg.append( " on line " ).append( ( ( Symbol )info ).left );
        }

        logger.error( msg.toString() );
    }
    
    // redefine cup parser methods for error reporting
    public void report_info( String message, Object info )
    {
    	StringBuilder msg = new StringBuilder( message ); 

    	if( info instanceof Symbol )
        {
            msg.append( " on line " ).append( ( ( Symbol )info ).left );
        }

        logger.info( msg.toString() );
    }
    
:}

scan with {:
	Symbol symbol = this.getScanner().next_token();
    logger.info( sym.symbolToString( symbol ) );
	return symbol;
:}





// ________________________________________________________________________________________________
// language characters


// keywords [terminals]
terminal PROGRAM_K, CLASS_K, /*ENUM_K,*/ EXTENDS_K;   // enum currently not used
terminal STATIC_K, CONST_K, VOID_K;
terminal IF_K, ELSE_K, SWITCH_K, CASE_K, BREAK_K, CONTINUE_K, RETURN_K;
terminal DO_K, WHILE_K;
terminal NEW_K, PRINT_K, READ_K;

// operators [terminals]
//       +     -      *    /    %
terminal plus, minus, mul, div, perc;
//       ==  !=  >   >=  <   <=  &&   ||
terminal eq, ne, gt, ge, lt, le, and, or;
//       =       ++        --
terminal assign, plusplus, minusminus;
//       ;        ,      .    {       }       (       )       [         ]         :
terminal semicol, comma, dot, lbrace, rbrace, lparen, rparen, lbracket, rbracket, colon;

// literals [terminals]
terminal Integer int_lit;      // 0   10   12012
terminal Boolean bool_lit;     // true   false
terminal Character char_lit;   // 'a'   '-'

// identifiers [terminals]
terminal String ident;         // asdf0_13



// declarations [nonterminals]
nonterminal Program, GlobalDeclList, GlobalDecl;
nonterminal ClassDecl, ClassDeclScope, ClassVarDeclList, ClassVarDecl, MethodDeclScope, MethodDeclList;
nonterminal MethodDecl, FormPars, FormParsNext, VarDeclList;
nonterminal VarDecl, VarIdentList;
nonterminal ConstDecl, IdentInitList;

// statement parts [nonterminals]
nonterminal Statement, DesignatorStatement;
nonterminal StatementList, CaseList, ActPars, ActParsNext;
nonterminal Condition, CondTerm, CondFact;
nonterminal Expr, Addition, SignedAddition;
nonterminal Term, Factor;
nonterminal Designator, DesignatorNext;

// types, literals, operators [nonterminals]
nonterminal VarIdent, Literal, ReturnType, Type;
nonterminal Assignop, Relop, Addop, Mulop;



// associativity [terminals]
precedence left ELSE_K;        // left associative operation => 'else' is paired with the closest left 'if'

// starting non-terminal
start with Program;





// ________________________________________________________________________________________________
// language rules


// program ident { }
// program ident { method method method }
// program ident constdl constdl vardl vardl classdl { }
// program ident constdl constdl vardl vardl classdl { method method method }
Program ::= (Program_Plain) PROGRAM_K ident GlobalDeclList MethodDeclScope;

// <epsilon>
// constdl constdl vardl vardl classdl
GlobalDeclList ::= (GlobalDeclList_Tail ) GlobalDecl GlobalDeclList;
GlobalDeclList ::= (GlobalDeclList_Empty) ;

GlobalDecl ::= (GlobalDecl_Const) ConstDecl;
GlobalDecl ::= (GlobalDecl_Var  ) VarDecl;
GlobalDecl ::= (GlobalDecl_Class) ClassDecl;



// class A { }
// class A { { method method method } }
// class A extends B { vardl vardl vardl vardl }
// class A extends B { vardl vardl vardl vardl { method method method } }
ClassDecl ::= (ClassDecl_Plain  ) CLASS_K ident                ClassDeclScope;
ClassDecl ::= (ClassDecl_Extends) CLASS_K ident EXTENDS_K Type ClassDeclScope;

// { }
// { { method method method } }
// { vardl vardl vardl vardl }
// { vardl vardl vardl vardl { method method method } }
ClassDeclScope ::= (ClassDeclScope_Vars       ) lbrace ClassVarDeclList                 rbrace;
ClassDeclScope ::= (ClassDeclScope_VarsMethods) lbrace ClassVarDeclList MethodDeclScope rbrace;

// <epsilon>
// clsvardl clsvardl clsvardl clsvardl
ClassVarDeclList ::= (ClassVarDeclList_VarDecl) ClassVarDecl ClassVarDeclList;
ClassVarDeclList ::= (ClassVarDeclList_Empty  ) ;

// int a, b[], c;
// A a1, a2;
// static int a, b[], c;
// static A a1, a2;
ClassVarDecl ::= (ClassVarDecl_Plain )          Type VarIdentList semicol;
ClassVarDecl ::= (ClassVarDecl_Static) STATIC_K Type VarIdentList semicol;

// { }
// { method method method }
MethodDeclScope ::= (MethodDeclScope_Plain) lbrace MethodDeclList rbrace;

MethodDeclList ::= (MethodDeclList_Tail ) MethodDecl MethodDeclList;
MethodDeclList ::= (MethodDeclList_Empty) ;



// void foo() { }
// void foo() { statement statement }
// void foo() vardl vardl { }
// void foo() vardl vardl { statement statement }
// void foo( int a, char c, Node Array[] ) { }
// void foo( int a, char c, Node Array[] ) { statement statement }
// void foo( int a, char c, Node Array[] ) vardl vardl { }
// void foo( int a, char c, Node Array[] ) vardl vardl { statement statement }
MethodDecl ::= (MethodDecl_Plain) ReturnType ident lparen FormPars rparen VarDeclList lbrace StatementList rbrace;

// <epsilon>
// int ident, Node Array[], char c
FormPars ::= (FormPars_Tail ) Type VarIdent FormParsNext;
FormPars ::= (FormPars_Empty) ;

FormParsNext ::= (FormParsNext_FormPar) comma Type VarIdent FormParsNext;
FormParsNext ::= (FormParsNext_Empty  ) ;

// <epsilon>
// vardl vardl vardl vardl
VarDeclList ::= (VarDeclList_VarDecl) VarDecl VarDeclList;
VarDeclList ::= (VarDeclList_Empty  ) ;



// int a, b[], c;
// A a1, a2;
VarDecl ::= (VarDecl_Plain) Type VarIdentList semicol;

VarIdentList ::= (VarIdentList_VarIdent) VarIdent;
VarIdentList ::= (VarIdentList_Tail    ) VarIdent comma VarIdentList;



// const int a = 5, b = 6, c = 11;
ConstDecl ::= (ConstDecl_Plain) CONST_K Type IdentInitList semicol;

IdentInitList ::= (IdentInitList_Init) ident Assignop Literal;
IdentInitList ::= (IdentInitList_Tail) ident Assignop Literal comma IdentInitList;



// ident.ident[ expr ] = expr;
// ident.ident[ expr ]( );
// ident.ident[ expr ]( expr, expr, expr );
// ident.ident[ expr ]++;
// ident.ident[ expr ]--;
//
// if( condition ) statement
// if( condition ) statement else statement
// do statement while( condition );
// switch( expr ) { }
// switch( expr ) { case 1: statement statement statement   case 2: statement statement }
// break;
// continue;
// return;
// return expr;
//
// read( ident.ident[ expr ] );
// print( ident.ident[ expr ], 2 );
//
// {}
// { statement statement statement }
Statement ::= (Statement_Designator ) DesignatorStatement semicol;
Statement ::= (Statement_If         ) IF_K lparen Condition rparen Statement;
Statement ::= (Statement_IfElse     ) IF_K lparen Condition rparen Statement ELSE_K Statement;
Statement ::= (Statement_DoWhile    ) DO_K Statement WHILE_K lparen Condition rparen semicol;
Statement ::= (Statement_Switch     ) SWITCH_K lparen Expr rparen lbrace CaseList rbrace;
Statement ::= (Statement_Break      ) BREAK_K semicol;
Statement ::= (Statement_Continue   ) CONTINUE_K semicol;
Statement ::= (Statement_Return     ) RETURN_K semicol;
Statement ::= (Statement_ReturnExpr ) RETURN_K Expr semicol;
Statement ::= (Statement_Read       ) READ_K lparen Designator rparen semicol;
Statement ::= (Statement_Print      ) PRINT_K lparen Expr rparen semicol;
Statement ::= (Statement_PrintFormat) PRINT_K lparen Expr comma int_lit rparen semicol;
Statement ::= (Statement_Scope      ) lbrace StatementList rbrace;
Statement ::= (Statement_Semicolon  ) semicol;

// ident.ident[ expr ] = expr
// ident.ident[ expr ]( )
// ident.ident[ expr ]( expr, expr, expr )
// ident.ident[ expr ]++
// ident.ident[ expr ]--
DesignatorStatement ::= (DesignatorStatement_Assign    ) Designator Assignop Expr;
DesignatorStatement ::= (DesignatorStatement_Call      ) Designator lparen ActPars rparen;
DesignatorStatement ::= (DesignatorStatement_Plusplus  ) Designator plusplus;
DesignatorStatement ::= (DesignatorStatement_Minusminus) Designator minusminus;



// <epsilon>
// statement statement statement statement
StatementList ::= (StatementList_Tail ) Statement StatementList;
StatementList ::= (StatementList_Empty) ;

// <epsilon>
// case 1: statement statement statement   case 2: statement statement
CaseList ::= (CaseList_Tail ) CASE_K int_lit colon StatementList CaseList;
CaseList ::= (CaseList_Empty) ;

// <epsilon>
// expr
// expr, expr, expr
ActPars ::= (ActPars_Tail ) Expr ActParsNext;
ActPars ::= (ActPars_Empty) ;

ActParsNext ::= (ActParsNext_Tail ) comma Expr ActParsNext;
ActParsNext ::= (ActParsNext_Empty) ;

// expr   or   expr < expr and expr >= expr  or  expr != expr   // 'and' has greater priority than 'or'!
Condition ::= (Condition_Term) CondTerm;
Condition ::= (Condition_Tail) CondTerm or Condition;

CondTerm ::= (CondTerm_Fact) CondFact;
CondTerm ::= (CondTerm_Tail) CondFact and CondTerm;

CondFact ::= (CondFact_Expr) Expr;
CondFact ::= (CondFact_Tail) Expr Relop Expr;

// term
// +term
// -term
// term + term - term + term
// -term + term - term + term
// +term + term + term + term
Expr ::= (Expr_Addition) Addition;

Addition ::= (Addition_Term    ) Term;
Addition ::= (Addition_Tail    )      SignedAddition;
Addition ::= (Addition_TermTail) Term SignedAddition;

SignedAddition ::= (SignedAddition_Term) Addop Term;
SignedAddition ::= (SignedAddition_Tail) Addop Term SignedAddition;



// factor
// factor*factor*factor
Term ::= (Term_Factor) Factor;
Term ::= (Term_Tail  ) Factor Mulop Term;

// ident.ident[ expr ]
// ident.ident[ expr ]( )
// ident.ident[ expr ]( expr, expr, expr )
// 1202 | 'c' | true
// new Object
// new Array[ expr ]
// ( expr )
Factor ::= (Factor_Designator    ) Designator;
Factor ::= (Factor_DesignatorCall) Designator lparen ActPars rparen;
Factor ::= (Factor_Literal       ) Literal;
Factor ::= (Factor_NewVar        ) NEW_K Type;
Factor ::= (Factor_NewArray      ) NEW_K Type lbracket Expr rbracket;
Factor ::= (Factor_Expr          ) lparen Expr rparen;

// ident
// ident.ident
// ident[ expr ]
// ident.ident.ident[ expr ].ident
// ident.ident.ident[ expr ].ident[ expr ]
Designator ::= (Designator_Plain) ident DesignatorNext;

DesignatorNext ::= (DesignatorNext_FieldTail) dot ident              DesignatorNext;
DesignatorNext ::= (DesignatorNext_ElemTail ) lbracket Expr rbracket DesignatorNext;
DesignatorNext ::= (DesignatorNext_Empty    ) ;



// ident | array[]
VarIdent ::= (VarIdent_Ident) ident;
VarIdent ::= (VarIdent_Array) ident lbracket rbracket;
// 1202 | 'c' | true
Literal ::= (Literal_Int ) int_lit;
Literal ::= (Literal_Char) char_lit;
Literal ::= (Literal_Bool) bool_lit;
// void | type
ReturnType ::= (ReturnType_Void ) VOID_K;
ReturnType ::= (ReturnType_Ident) ident;
// int | bool | char | ident
Type ::= (Type_Ident) ident;

// =
Assignop ::= (Assignop_Assign) assign;
// ==  |  !=  |  >  |  >=  |  <  |  <=
Relop ::= (Relop_Eq ) eq;
Relop ::= (Relop_Neq) ne;
Relop ::= (Relop_Gt ) gt;
Relop ::= (Relop_Geq) ge;
Relop ::= (Relop_Lt ) lt;
Relop ::= (Relop_Leq) le;
// +  |  -
Addop ::= (Addop_Plus ) plus;
Addop ::= (Addop_Minus) minus;
// *  |  /  |  %
Mulop ::= (Mulop_Mul ) mul;
Mulop ::= (Mulop_Div ) div;
Mulop ::= (Mulop_Perc) perc;






