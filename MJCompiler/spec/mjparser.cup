// ________________________________________________________________________________________________
// import section
package rs.ac.bg.etf.pp1;

import rs.ac.bg.etf.pp1.ast.*;
import rs.ac.bg.etf.pp1.util.Log4J;


// ________________________________________________________________________________________________
// directive section

parser code {:
	private boolean errorDetected = false;
	private boolean fatalErrorDetected = false;

    private Symbol currSymbol = null;
    private SymbolList errorSymbols = new SymbolList();


    // check if there are parse errors
    public boolean hasErrors()     { return errorDetected || fatalErrorDetected; }
    public boolean hasFatalError() { return fatalErrorDetected; }


    @Override
    protected int error_sync_size() { return 1; }

    // NOTE: info is currently unused
    @Override
    public void report_fatal_error( String message, Object info )
    {
        fatalErrorDetected = true;

        report_error( message, info );
        done_parsing();
    }

    // NOTE: info is currently unused
    @Override
    public void report_error( String message, Object info )
    {
    	errorDetected = true;

        // ignore default messages (lr parser messages that can't be replaced without rewriting that part of the parser in the .jar file)
        if( message == null
        || "Syntax error".equals( message )
        || "Couldn't repair and continue parse".equals( message ) )
        {
            message = null;
        }

        // if a fatal error is detected and the message is null, set the default fatal error message
        if( fatalErrorDetected && message == null )
        {
            message = "Fatal error detected, parsing stopped";
        }

        // if the error symbol list is empty, add the first error symbol to the error symbol list
        if( errorSymbols.size() == 0 ) errorSymbols.add( currSymbol );

        // if the message is not ready, don't report yet
        if( message == null ) return;
        

        // if the error is not fatal and the error symbol list was not empty beforehand, remove excess non-error tokens
        // +   ignored symbols are not counted towards the quota while removing
        // +   the last symbol after this will definitely be an error symbol
        if( !fatalErrorDetected && errorSymbols.size() > 1 )
        {
            int errorSymbolCount = error_sync_size() + 1;
            for( int i = 0; i <= errorSymbolCount;   )
            {
                // if the list's last symbol is not an ignored symbol, increment the counter of excess non-error non-ignored symbols
                if( !errorSymbols.getLast().isIgnored() ) i++;

                // if this is the first non-excess symbol at the end of the list or if there is only one element to show, break
                if( i == errorSymbolCount + 1 || errorSymbols.size() <= 1 ) break;
                
                // remove the list's last element
                errorSymbols.removeLast();
            }
        }

        // calculate the from and to error symbols' indexes
        int symbolFromIdx = CompilerError.NO_INDEX;
        int symbolToIdx = CompilerError.NO_INDEX;

        if( errorSymbols.size() > 0 )
        {
            symbolFromIdx = ( ( Symbol )errorSymbols.getFirst() ).getIdx();
            if( !fatalErrorDetected ) symbolToIdx = ( ( Symbol )errorSymbols.getLast() ).getIdx() + 1;
            else                      symbolToIdx = symbolFromIdx + 1;

            // clear all error symbols in the current syntax error
            errorSymbols.clear();
        }


        // report the syntax error
        Compiler.errors.add( CompilerError.SYNTAX_ERROR, message, symbolFromIdx, symbolToIdx );
    }
    

    // this function is not designed for advanced error logging
    // +   ignore the <message> and current <symbol/ast node>
    protected void unrecovered_syntax_error( Symbol cur_token )
    {
        report_fatal_error( null, cur_token );
    }

    // this function is not designed for advanced error logging
    // +   ignore the <message> and current <symbol/ast node>
    protected void syntax_error( Symbol cur_token )
    {
        report_error( null, cur_token );
    }

:}

scan with {:
    while( true )
    {
        // replace the current symbol with the next symbol from the scanner
    	currSymbol = ( Symbol )( getScanner().next_token() );

        // if the parser is currently resolving an error, save the symbol
        if( errorSymbols.size() > 0 )
        {
            errorSymbols.add( currSymbol );
        }

        // if the current symbol should not be ignored
        if( !currSymbol.isIgnored() )
        {
            // log the current symbol and break
            Compiler.logger.log( Log4J.INFO, currSymbol.toString(), true );
            break;
        }
    }

    // if the current symbol is invalid
    if( currSymbol.isInvalid() )
    {
        // report it as a lexer error
        Compiler.errors.add( CompilerError.LEXICAL_ERROR, "Bad token", currSymbol.getIdx(), currSymbol.getIdx()+1  );
    }

    // return the current symbol
    return currSymbol;
:}





// ________________________________________________________________________________________________
// language characters


// keywords [terminals]
terminal PROGRAM_K, CLASS_K, /*ENUM_K,*/ EXTENDS_K;   // enum currently not supported
terminal STATIC_K, CONST_K, VOID_K;
terminal IF_K, ELSE_K, SWITCH_K, CASE_K, BREAK_K, CONTINUE_K, RETURN_K;
terminal DO_K, WHILE_K;
terminal NEW_K, PRINT_K, READ_K;

// operators [terminals]
//       +     -      *    /    %
terminal plus, minus, mul, div, perc;
//       ==  !=  >   >=  <   <=  &&   ||
terminal eq, ne, gt, ge, lt, le, and, or;
//       =       ++        --
terminal assign, plusplus, minusminus;
//       ;        ,      .    {       }       (       )       [         ]         :
terminal semicol, comma, dot, lbrace, rbrace, lparen, rparen, lbracket, rbracket, colon;

// literals [terminals]
terminal Integer int_lit;      // 0   10   12012
terminal Boolean bool_lit;     // true   false
terminal Character char_lit;   // 'a'   '-'

// identifiers [terminals]
terminal String ident;         // asdf0_13

// ignored symbols [terminals]
// +   whitespaces do not include newlines!
terminal newline, whitespace, line_comment, multi_comment;
// error symbol in lexer [terminals]
// +   used instead of error, since then the parser doesn't skip reporting it as an error
terminal invalid;



// declarations [nonterminals]
nonterminal Program;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgramType;
nonterminal GlobalDeclList;
nonterminal GlobalDecl;

nonterminal ClassDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ClassDeclType;
nonterminal ClassDeclBody;
nonterminal MethodDeclList;

nonterminal MethodDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDeclType;
nonterminal FormPars;
nonterminal FormParsList;
nonterminal rs.etf.pp1.symboltable.concepts.Obj FormParam;
nonterminal VarDeclList;

nonterminal VarDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj VarDeclType;
nonterminal VarIdentList;
nonterminal rs.etf.pp1.symboltable.concepts.Obj VarIdent;

nonterminal ConstDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ConstDeclType;
nonterminal ConstInitList;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ConstInit;



// statements [nonterminals]
nonterminal Statement;
nonterminal DesignatorStatement;
nonterminal StatementList;

nonterminal CaseList;
nonterminal Case;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ActPars;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ActParsList;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Condition;
nonterminal rs.etf.pp1.symboltable.concepts.Obj CondTerm;
nonterminal rs.etf.pp1.symboltable.concepts.Obj CondFact;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Expr;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Addition;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Term;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Factor;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator;



// miscellaneous [nonterminals]
nonterminal OpenScope;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ReturnType;  // value, type
nonterminal rs.etf.pp1.symboltable.concepts.Obj Type;        // value, type
nonterminal rs.etf.pp1.symboltable.concepts.Obj Literal;     // value, type

nonterminal Assignop;
nonterminal Relop;
nonterminal Addop;
nonterminal Mulop;



// associativity
precedence left ELSE_K;        // left associative operation => 'else' is paired with the closest left 'if'

// starting non-terminal
start with Program;





// ________________________________________________________________________________________________
// language rules


// program ident { }
// program ident { method method method }
// program ident constdl constdl vardl vardl classdl { }
// program ident constdl constdl vardl vardl classdl { method method method }
Program ::= (Program_Plain) ProgramType GlobalDeclList lbrace MethodDeclList rbrace;

// program my_program
ProgramType ::= (ProgramType_Plain) PROGRAM_K ident:ProgramName;

// <epsilon>
// constdl constdl vardl vardl classdl
GlobalDeclList ::= (GlobalDeclList_Tail ) GlobalDeclList GlobalDecl;
GlobalDeclList ::= (GlobalDeclList_Empty) ;

// constdl
// vardl
// classdl
GlobalDecl ::= (GlobalDecl_Const) ConstDecl;
GlobalDecl ::= (GlobalDecl_Var  ) VarDecl;
GlobalDecl ::= (GlobalDecl_Class) ClassDecl;



// class A { }
// class A { { method method method } }
// class A extends B { vardl vardl vardl vardl }
// class A extends B { vardl vardl vardl vardl { method method method } }
ClassDecl ::= (ClassDecl_Plain) ClassDeclType lbrace OpenScope ClassDeclBody rbrace;

// class A
// class A extends B
ClassDeclType ::= (ClassDeclType_Plain  ) CLASS_K ident:ClassName;
ClassDeclType ::= (ClassDeclType_Extends) CLASS_K ident:ClassName EXTENDS_K Type;
ClassDeclType ::= (ClassDeclType_Err    ) CLASS_K error {: parser.report_error( "Bad class declaration", null ); :};

// <epsilon>
// { method method method }
// vardl vardl vardl vardl
// vardl vardl vardl vardl { method method method }
ClassDeclBody ::= (ClassDeclBody_Vars       ) VarDeclList;
ClassDeclBody ::= (ClassDeclBody_VarsMethods) VarDeclList lbrace OpenScope MethodDeclList rbrace;

// <epsilon>
// method method method
MethodDeclList ::= (MethodDeclList_Tail ) MethodDeclList MethodDecl;
MethodDeclList ::= (MethodDeclList_Empty) ;



// void foo() { }
// void foo() { statement statement }
// void foo() vardl vardl { }
// void foo() vardl vardl { statement statement }
// void foo( int a, char c, Node Array[] ) { }
// void foo( int a, char c, Node Array[] ) { statement statement }
// void foo( int a, char c, Node Array[] ) vardl vardl { }
// void foo( int a, char c, Node Array[] ) vardl vardl { statement statement }
MethodDecl ::= (MethodDecl_Plain) MethodDeclType lparen OpenScope FormPars rparen OpenScope VarDeclList lbrace StatementList rbrace;

// void foo
// A foo
MethodDeclType ::= (MethodDeclType_Plain) ReturnType ident:MethodName;

// <epsilon>
// int ident, Node Array[], char c
FormPars ::= (FormPars_List ) FormParsList;
FormPars ::= (FormPars_Empty) ;

// int a, char c, Node Array[]
FormParsList ::= (FormParsList_Init)                    FormParam;
FormParsList ::= (FormParsList_Tail) FormParsList comma FormParam;

// int a, char c, Node Array[]
FormParam ::= (FormParam_Plain) Type VarIdent;
FormParam ::= (FormParam_Err  ) error {: parser.report_error( "Bad formal parameter", null ); :};

// <epsilon>
// vardl vardl vardl vardl
VarDeclList ::= (VarDeclList_VarDecl) VarDeclList VarDecl;
VarDeclList ::= (VarDeclList_Empty  ) ;



// int a, b[], c;
// A a1, a2;
// static int a, b[], c;   // the static keyword is only allowed inside a class declaration!
// static A a1, a2;
VarDecl ::= (VarDecl_Plain) VarDeclType VarIdentList semicol;

// int
// static A
VarDeclType ::= (VarDeclType_Plain )          Type;
VarDeclType ::= (VarDeclType_Static) STATIC_K Type;
VarDeclType ::= (VarDeclType_Err   ) error {: parser.report_error( "Bad class declaration", null ); :};

// a
// a, b[], c
VarIdentList ::= (VarIdentList_VarIdent)                    VarIdent;
VarIdentList ::= (VarIdentList_Tail    ) VarIdentList comma VarIdent;

// a
// b[]
VarIdent ::= (VarIdent_Ident) ident:VarName;
VarIdent ::= (VarIdent_Array) ident:VarName lbracket rbracket;
VarIdent ::= (VarIdent_Err  ) error {: parser.report_error( "Bad variable declaration", null ); :};



// const int a = 5, b = 6, c = 11;
ConstDecl ::= (ConstDecl_Plain) ConstDeclType ConstInitList semicol;

// const int
ConstDeclType ::= (ConstDeclType_Plain) CONST_K Type;
ConstDeclType ::= (ConstDeclType_Err  ) CONST_K error {: parser.report_error( "Bad constant type", null ); :};

// a = 5, b = 6, c = 11
ConstInitList ::= (ConstInitList_Init)                     ConstInit;
ConstInitList ::= (ConstInitList_Tail) ConstInitList comma ConstInit;

// a = 5
ConstInit ::= (ConstInit_Plain) ident:IdentName Assignop Literal;
ConstInit ::= (ConstInit_Err  ) error {: parser.report_error( "Bad initialization", null ); :};






// ident.ident[ expr ] = expr;
// ident.ident[ expr ]( );
// ident.ident[ expr ]( expr, expr, expr );
// ident.ident[ expr ]++;
// ident.ident[ expr ]--;
//
// if( condition ) statement
// if( condition ) statement else statement
// do statement while( condition );
// switch( expr ) { }
// switch( expr ) { case 1: statement statement statement   case 2: statement statement }
// break;
// continue;
// return;
// return expr;
//
// read( ident.ident[ expr ] );
// print( ident.ident[ expr ], 2 );
//
// {}
// { statement statement statement }
Statement ::= (Statement_Designator ) DesignatorStatement semicol;
Statement ::= (Statement_If         ) IF_K lparen Condition rparen Statement;
Statement ::= (Statement_IfElse     ) IF_K lparen Condition rparen Statement ELSE_K Statement;
Statement ::= (Statement_DoWhile    ) DO_K Statement WHILE_K lparen Condition rparen semicol;
Statement ::= (Statement_Switch     ) SWITCH_K lparen Expr rparen lbrace CaseList rbrace;
Statement ::= (Statement_Break      ) BREAK_K       semicol;
Statement ::= (Statement_Continue   ) CONTINUE_K    semicol;
Statement ::= (Statement_Return     ) RETURN_K      semicol;
Statement ::= (Statement_ReturnExpr ) RETURN_K Expr semicol;
Statement ::= (Statement_Read       ) READ_K lparen Designator rparen semicol;
Statement ::= (Statement_Print      ) PRINT_K lparen Expr                        rparen semicol;
Statement ::= (Statement_PrintFormat) PRINT_K lparen Expr comma int_lit:MinWidth rparen semicol;
Statement ::= (Statement_Scope      ) lbrace OpenScope StatementList rbrace;
Statement ::= (Statement_Semicolon  ) semicol;
Statement ::= (Statement_Err        ) error {: parser.report_error( "Bad statement", null ); :};

// ident.ident[ expr ] = expr
// ident.ident[ expr ]( )
// ident.ident[ expr ]( expr, expr, expr )
// ident.ident[ expr ]++
// ident.ident[ expr ]--
DesignatorStatement ::= (DesignatorStatement_Assign    ) Designator Assignop Expr;
DesignatorStatement ::= (DesignatorStatement_Call      ) Designator lparen ActPars rparen;
DesignatorStatement ::= (DesignatorStatement_Plusplus  ) Designator plusplus;
DesignatorStatement ::= (DesignatorStatement_Minusminus) Designator minusminus;

// <epsilon>
// statement statement statement statement
StatementList ::= (StatementList_Tail ) StatementList Statement;
StatementList ::= (StatementList_Empty) ;

// <epsilon>
// case 1: statement statement statement   case 2: statement statement
CaseList ::= (CaseList_Tail ) CaseList Case;
CaseList ::= (CaseList_Empty) ;

// case 1: statement statement statement
// case 2: 
// case 3: {}
Case ::= (Case_Plain) CASE_K int_lit:CaseNum colon StatementList;



// <epsilon>
// expr
// expr, expr, expr
ActPars ::= (ActPars_Plain) ActParsList;
ActPars ::= (ActPars_Empty) ;

// expr
// expr, expr, expr
ActParsList ::= (ActParsList_Expr)                   Expr;
ActParsList ::= (ActParsList_Tail) ActParsList comma Expr;

// expr   or   expr < expr and expr >= expr  or  expr != expr   // 'and' has greater priority than 'or'!
Condition ::= (Condition_Term)              CondTerm;
Condition ::= (Condition_Tail) Condition or CondTerm;

// expr < expr and expr >= expr
CondTerm ::= (CondTerm_Fact)              CondFact;
CondTerm ::= (CondTerm_Tail) CondTerm and CondFact;

// expr < expr and expr >= expr
CondFact ::= (CondFact_Expr) Expr;
CondFact ::= (CondFact_Tail) Expr Relop Expr;

// +term - term + term + term
Expr ::= (Expr_Addition) Addition;
Expr ::= (Expr_Err     ) error {: parser.report_error( "Bad expression", null ); :};

// term
// +term
// -term
// term + term - term + term
// -term + term - term + term
// +term + term + term + term
Addition ::= (Addition_Term )                Term;
Addition ::= (Addition_STerm)          Addop Term;
Addition ::= (Addition_Tail ) Addition Addop Term;

// factor
// factor*factor*factor
Term ::= (Term_Factor)            Factor;
Term ::= (Term_Tail  ) Term Mulop Factor;



// ident.ident[ expr ]
// ident.ident[ expr ]( )
// ident.ident[ expr ]( expr, expr, expr )
// 1202 | 'c' | true
// new Object
// new Array[ expr ]
// ( expr )
Factor ::= (Factor_Designator    ) Designator;
Factor ::= (Factor_DesignatorCall) Designator lparen ActPars rparen;
Factor ::= (Factor_Literal       ) Literal;
Factor ::= (Factor_NewVar        ) NEW_K Type;
Factor ::= (Factor_NewArray      ) NEW_K Type lbracket Expr rbracket;
Factor ::= (Factor_Expr          ) lparen Expr rparen;

// ident
// ident.ident
// ident[ expr ]
// ident.ident.ident[ expr ].ident
// ident.ident.ident[ expr ].ident[ expr ]
Designator ::= (Designator_Ident  ) ident:Name;
Designator ::= (Designator_Field  ) Designator dot ident:Name;
Designator ::= (Designator_ArrElem) Designator lbracket Expr rbracket;






// action symbol for opening a new scope
OpenScope ::= (OpenScope_Plain) ;

// void | type
ReturnType ::= (ReturnType_Void ) VOID_K:ReturnType;
ReturnType ::= (ReturnType_Ident) ident :ReturnType;
// int | bool | char | ident
Type ::= (Type_Ident) ident:Type;
// 1202 | 'c' | true
Literal ::= (Literal_Int ) int_lit :Literal;
Literal ::= (Literal_Char) char_lit:Literal;
Literal ::= (Literal_Bool) bool_lit:Literal;

// =
Assignop ::= (Assignop_Assign) assign:Assignop;
// ==  |  !=  |  >  |  >=  |  <  |  <=
Relop ::= (Relop_Eq ) eq:Relop;
Relop ::= (Relop_Neq) ne:Relop;
Relop ::= (Relop_Gt ) gt:Relop;
Relop ::= (Relop_Geq) ge:Relop;
Relop ::= (Relop_Lt ) lt:Relop;
Relop ::= (Relop_Leq) le:Relop;
// +  |  -
Addop ::= (Addop_Plus ) plus :Addop;
Addop ::= (Addop_Minus) minus:Addop;
// *  |  /  |  %
Mulop ::= (Mulop_Mul ) mul :Mulop;
Mulop ::= (Mulop_Div ) div :Mulop;
Mulop ::= (Mulop_Perc) perc:Mulop;






