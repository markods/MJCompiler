// ________________________________________________________________________________________________
// import section
package rs.ac.bg.etf.pp1;

import rs.ac.bg.etf.pp1.ast.*;
import rs.ac.bg.etf.pp1.util.Log4J;


// ________________________________________________________________________________________________
// directive section

parser code {:
	private boolean errorDetected = false;
	private boolean fatalErrorDetected = false;

    private Token currToken = null;
    private TokenList errorTokens = new TokenList();


    // check if there are parse errors
    public boolean hasErrors()     { return errorDetected || fatalErrorDetected; }
    public boolean hasFatalError() { return fatalErrorDetected; }


    @Override
    protected int error_sync_size() { return 1; }

    // NOTE: info is currently unused
    @Override
    public void report_fatal_error( String message, Object info )
    {
        fatalErrorDetected = true;

        report_error( message, info );
        done_parsing();
    }

    // NOTE: info is currently unused
    @Override
    public void report_error( String message, Object info )
    {
    	errorDetected = true;

        // ignore default messages (lr parser messages that can't be replaced without rewriting that part of the parser in the .jar file)
        if( message == null
        || "Syntax error".equals( message )
        || "Couldn't repair and continue parse".equals( message ) )
        {
            message = null;
        }

        // if a fatal error is detected and the message is null, set the default fatal error message
        if( fatalErrorDetected && message == null )
        {
            message = "Fatal error detected, parsing stopped";
        }

        // if the error token list is empty, add the first error token to the error token list
        if( errorTokens.size() == 0 ) errorTokens.add( currToken );

        // if the message is not ready, don't report yet
        if( message == null ) return;
        

        // if the error is not fatal and the error token list was not empty beforehand, remove excess non-error tokens
        // +   ignored tokens are not counted towards the quota while removing
        // +   the last token after this will definitely be an error token
        if( !fatalErrorDetected && errorTokens.size() > 1 )
        {
            int errorTokenCount = error_sync_size() + 1;
            for( int i = 0; i <= errorTokenCount;   )
            {
                // if the list's last token is not an ignored token, increment the counter of excess non-error non-ignored tokens
                if( !errorTokens.getLast().isIgnored() ) i++;

                // if this is the first non-excess token at the end of the list or if there is only one element to show, break
                if( i == errorTokenCount + 1 || errorTokens.size() <= 1 ) break;
                
                // remove the list's last element
                errorTokens.removeLast();
            }
        }

        // calculate the from and to error tokens' indexes
        int tokenFromIdx = CompilerError.NO_INDEX;
        int tokenToIdx = CompilerError.NO_INDEX;

        if( errorTokens.size() > 0 )
        {
            tokenFromIdx = ( ( Token )errorTokens.getFirst() ).getIdx();
            if( !fatalErrorDetected ) tokenToIdx = ( ( Token )errorTokens.getLast() ).getIdx() + 1;
            else                      tokenToIdx = tokenFromIdx + 1;

            // clear all error tokens in the current syntax error
            errorTokens.clear();
        }


        // report the syntax error
        Compiler.errors.add( CompilerError.SYNTAX_ERROR, message, tokenFromIdx, tokenToIdx );
    }
    

    // this function is not designed for advanced error logging
    // +   ignore the <message> and current <token/ast node>
    protected void unrecovered_syntax_error( Token cur_token )
    {
        report_fatal_error( null, cur_token );
    }

    // this function is not designed for advanced error logging
    // +   ignore the <message> and current <token/ast node>
    protected void syntax_error( Token cur_token )
    {
        report_error( null, cur_token );
    }

:}

scan with {:
    while( true )
    {
        // replace the current token with the next token from the scanner
    	currToken = ( Token )( getScanner().next_token() );

        // if the parser is currently resolving an error, save the token
        if( errorTokens.size() > 0 )
        {
            errorTokens.add( currToken );
        }

        // if the current token should not be ignored
        if( !currToken.isIgnored() )
        {
            // log the current token and break
            Compiler.logger.log( Log4J.INFO, currToken.toString(), true );
            break;
        }
    }

    // if the current token is invalid
    if( currToken.isInvalid() )
    {
        // report it as a lexer error
        Compiler.errors.add( CompilerError.LEXICAL_ERROR, "Bad token", currToken.getIdx(), currToken.getIdx()+1  );
    }

    // return the current token
    return currToken;
:}





// ________________________________________________________________________________________________
// language characters


// keywords [terminals]
terminal PROGRAM_K, CLASS_K, /*ENUM_K,*/ EXTENDS_K;   // enum currently not supported
terminal STATIC_K, CONST_K, VOID_K, NULL_K;
terminal IF_K, ELSE_K, SWITCH_K, CASE_K, BREAK_K, CONTINUE_K, RETURN_K;
terminal DO_K, WHILE_K;
terminal NEW_K, PRINT_K, READ_K;

// operators [terminals]
//       +     -      *    /    %
terminal plus, minus, mul, div, perc;
//       ==  !=  >   >=  <   <=  &&   ||
terminal eq, ne, gt, ge, lt, le, and, or;
//       =       ++        --
terminal assign, plusplus, minusminus;
//       ;        ,      .    {       }       (       )       [         ]         :
terminal semicol, comma, dot, lbrace, rbrace, lparen, rparen, lbracket, rbracket, colon;

// literals [terminals]
terminal Integer int_lit;      // 0   10   12012
terminal Boolean bool_lit;     // true   false
terminal Character char_lit;   // 'a'   '-'

// identifiers [terminals]
terminal String ident;         // asdf0_13

// ignored tokens [terminals]
// +   whitespaces do not include newlines!
terminal newline, whitespace, line_comment, multi_comment;
// error token in lexer [terminals]
// +   used instead of error, since then the parser doesn't skip reporting it as an error
terminal invalid;



// declarations [nonterminals]
nonterminal Program;
nonterminal rs.ac.bg.etf.pp1.Symbol ProgramType;
nonterminal GlobalDeclList;
nonterminal GlobalDecl;

nonterminal ClassDecl;
nonterminal rs.ac.bg.etf.pp1.Symbol ClassDeclType;
nonterminal ClassDeclBody;
nonterminal MethodDeclList;

nonterminal MethodDecl;
nonterminal rs.ac.bg.etf.pp1.Symbol MethodDeclType;
nonterminal MethodDeclBody;
nonterminal MethodDeclCode;
nonterminal FormPars;
nonterminal FormParsScope;
nonterminal FormParsList;
nonterminal rs.ac.bg.etf.pp1.Symbol FormParam;
nonterminal rs.ac.bg.etf.pp1.Symbol FormParamType;
nonterminal VarDeclList;

nonterminal VarDecl;
nonterminal rs.ac.bg.etf.pp1.Symbol VarDeclType;
nonterminal VarIdentList;
nonterminal rs.ac.bg.etf.pp1.Symbol VarIdent;

nonterminal ConstDecl;
nonterminal rs.ac.bg.etf.pp1.Symbol ConstDeclType;
nonterminal ConstInitList;
nonterminal rs.ac.bg.etf.pp1.Symbol ConstInit;



// statements [nonterminals]
nonterminal Statement;

nonterminal java.lang.Integer IfCondition;        // contains the jump instruction's address
nonterminal java.lang.Integer IfStatement;        // contains the jump instruction's address
nonterminal java.lang.Integer ElseScope;          // contains the jump instruction's address
nonterminal java.lang.Integer ElseStatement;      // contains the jump instruction's address

nonterminal rs.ac.bg.etf.pp1.props.JumpProp DoWhileScope;   // contains the jump instructions' addresses
nonterminal java.lang.Integer DoWhileCondition;             // contains the jump instruction's address
nonterminal java.lang.Integer DoWhileConditionScope;        // contains the condition's starting address

nonterminal rs.ac.bg.etf.pp1.props.JumpProp SwitchExpr;   // contains the jump instructions' addresses

nonterminal DesignatorStatement;
nonterminal StatementList;

nonterminal CaseList;
nonterminal Case;
nonterminal java.lang.Integer CaseScope;   // contains the jump instruction's address

nonterminal ActPars;
nonterminal ActParsScope;
nonterminal ActParsList;
nonterminal rs.ac.bg.etf.pp1.Symbol ActParam;

nonterminal rs.ac.bg.etf.pp1.Symbol Condition;
nonterminal rs.ac.bg.etf.pp1.Symbol CondTerm;
nonterminal rs.ac.bg.etf.pp1.Symbol CondFact;

nonterminal rs.ac.bg.etf.pp1.Symbol Expr;
nonterminal rs.ac.bg.etf.pp1.Symbol Addition;
nonterminal rs.ac.bg.etf.pp1.Symbol Term;

nonterminal rs.ac.bg.etf.pp1.Symbol Factor;
nonterminal rs.ac.bg.etf.pp1.Symbol MethodCall;
nonterminal rs.ac.bg.etf.pp1.Symbol Designator;



// miscellaneous [nonterminals]
nonterminal rs.ac.bg.etf.pp1.Symbol ReturnType;  // value, type
nonterminal rs.ac.bg.etf.pp1.Symbol Type;        // value, type
nonterminal rs.ac.bg.etf.pp1.Symbol Literal;     // value, type

nonterminal rs.ac.bg.etf.pp1.Symbol Assignop;
nonterminal rs.ac.bg.etf.pp1.Symbol Relop;
nonterminal rs.ac.bg.etf.pp1.Symbol Addop;
nonterminal rs.ac.bg.etf.pp1.Symbol Mulop;



// associativity
precedence left ELSE_K;        // left associative operation => 'else' is paired with the closest left 'if'

// starting non-terminal
start with Program;





// ________________________________________________________________________________________________
// language rules


// program ident { }
// program ident { method method method }
// program ident constdl constdl vardl vardl classdl { }
// program ident constdl constdl vardl vardl classdl { method method method }
Program ::= (Program_Plain) ProgramType GlobalDeclList lbrace MethodDeclList rbrace;

// program my_program
ProgramType ::= (ProgramType_Plain) PROGRAM_K ident:ProgramName;

// <epsilon>
// constdl constdl vardl vardl classdl
GlobalDeclList ::= (GlobalDeclList_Tail ) GlobalDeclList GlobalDecl;
GlobalDeclList ::= (GlobalDeclList_Empty) ;

// constdl
// vardl
// classdl
GlobalDecl ::= (GlobalDecl_Const) ConstDecl;
GlobalDecl ::= (GlobalDecl_Var  ) VarDecl;
GlobalDecl ::= (GlobalDecl_Class) ClassDecl;



// class A { }
// class A { { method method method } }
// class A extends B { vardl vardl vardl vardl }
// class A extends B { vardl vardl vardl vardl { method method method } }
ClassDecl ::= (ClassDecl_Plain) ClassDeclType lbrace ClassDeclBody rbrace;

// class A
// class A extends B
ClassDeclType ::= (ClassDeclType_Plain  ) CLASS_K ident:ClassName;
ClassDeclType ::= (ClassDeclType_Extends) CLASS_K ident:ClassName EXTENDS_K Type;
ClassDeclType ::= (ClassDeclType_Err    ) CLASS_K error {: parser.report_error( "Bad class declaration", null ); :};

// <epsilon>
// { method method method }
// vardl vardl vardl vardl
// vardl vardl vardl vardl { method method method }
ClassDeclBody ::= (ClassDeclBody_Vars       ) VarDeclList;
ClassDeclBody ::= (ClassDeclBody_VarsMethods) VarDeclList lbrace MethodDeclList rbrace;

// <epsilon>
// method method method
MethodDeclList ::= (MethodDeclList_Tail ) MethodDeclList MethodDecl;
MethodDeclList ::= (MethodDeclList_Empty) ;



// void foo() { }
// void foo() { statement statement }
// void foo() vardl vardl { }
// void foo() vardl vardl { statement statement }
// void foo( int a, char c, Node Array[] ) { }
// void foo( int a, char c, Node Array[] ) { statement statement }
// void foo( int a, char c, Node Array[] ) vardl vardl { }
// void foo( int a, char c, Node Array[] ) vardl vardl { statement statement }
MethodDecl ::= (MethodDecl_Plain) MethodDeclType lparen FormPars rparen MethodDeclBody VarDeclList MethodDeclCode lbrace StatementList rbrace;

// void foo
// A foo
MethodDeclType ::= (MethodDeclType_Plain) ReturnType ident:MethodName;

// action symbol for opening a new scope
MethodDeclBody ::= (MethodDeclBody_Plain) ;

// action symbol for the beginning of the method code
MethodDeclCode ::= (MethodDeclCode_Plain) ;

// <epsilon>
// int ident, Node Array[], char c
FormPars ::= (FormPars_List ) FormParsScope FormParsList;
FormPars ::= (FormPars_Empty) FormParsScope ;

// action symbol for opening a new scope
FormParsScope ::= (FormParsScope_Plain) ;

// int a, char c, Node Array[]
FormParsList ::= (FormParsList_Init)                    FormParam;
FormParsList ::= (FormParsList_Tail) FormParsList comma FormParam;

// int a, char c, Node Array[]
FormParam ::= (FormParam_Plain) FormParamType VarIdent;
FormParam ::= (FormParam_Err  ) error {: parser.report_error( "Bad formal parameter", null ); :};

// int
// Node
FormParamType ::= (FormParamType_Plain) Type;

// <epsilon>
// vardl vardl vardl vardl
VarDeclList ::= (VarDeclList_VarDecl) VarDeclList VarDecl;
VarDeclList ::= (VarDeclList_Empty  ) ;



// int a, b[], c;
// A a1, a2;
// static int a, b[], c;   // the static keyword is only allowed inside a class declaration!
// static A a1, a2;
VarDecl ::= (VarDecl_Plain) VarDeclType VarIdentList semicol;

// int
// static A
VarDeclType ::= (VarDeclType_Plain )          Type;
VarDeclType ::= (VarDeclType_Static) STATIC_K Type;
VarDeclType ::= (VarDeclType_Err   ) error {: parser.report_error( "Bad class declaration", null ); :};

// a
// a, b[], c
VarIdentList ::= (VarIdentList_VarIdent)                    VarIdent;
VarIdentList ::= (VarIdentList_Tail    ) VarIdentList comma VarIdent;

// a
// b[]
VarIdent ::= (VarIdent_Ident) ident:VarName;
VarIdent ::= (VarIdent_Array) ident:VarName lbracket rbracket;
VarIdent ::= (VarIdent_Err  ) error {: parser.report_error( "Bad variable declaration", null ); :};



// const int a = 5, b = 6, c = 11;
ConstDecl ::= (ConstDecl_Plain) ConstDeclType ConstInitList semicol;

// const int
ConstDeclType ::= (ConstDeclType_Plain) CONST_K Type;
ConstDeclType ::= (ConstDeclType_Err  ) CONST_K error {: parser.report_error( "Bad constant type", null ); :};

// a = 5, b = 6, c = 11
ConstInitList ::= (ConstInitList_Init)                     ConstInit;
ConstInitList ::= (ConstInitList_Tail) ConstInitList comma ConstInit;

// a = 5
ConstInit ::= (ConstInit_Plain) ident:IdentName Assignop Literal;
ConstInit ::= (ConstInit_Err  ) error {: parser.report_error( "Bad initialization", null ); :};






// ident.ident[ expr ] = expr;
// ident.ident[ expr ]( );
// ident.ident[ expr ]( expr, expr, expr );
// ident.ident[ expr ]++;
// ident.ident[ expr ]--;
//
// if( condition ) statement
// if( condition ) statement else statement
// do statement while( condition );
// switch( expr ) { }
// switch( expr ) { case 1: statement statement statement   case 2: statement statement }
// break;
// continue;
// return;
// return expr;
//
// read( ident.ident[ expr ] );
// print( ident.ident[ expr ], 2 );
//
// {}
// { statement statement statement }
Statement ::= (Statement_Designator ) DesignatorStatement semicol;
Statement ::= (Statement_If         ) IF_K lparen IfCondition rparen IfStatement;
Statement ::= (Statement_IfElse     ) IF_K lparen IfCondition rparen IfStatement ElseScope ElseStatement;
Statement ::= (Statement_DoWhile    ) DoWhileScope Statement WHILE_K lparen DoWhileCondition rparen semicol;
Statement ::= (Statement_Switch     ) SWITCH_K lparen SwitchExpr rparen lbrace CaseList rbrace;
Statement ::= (Statement_Break      ) BREAK_K       semicol;
Statement ::= (Statement_Continue   ) CONTINUE_K    semicol;
Statement ::= (Statement_Return     ) RETURN_K      semicol;
Statement ::= (Statement_ReturnExpr ) RETURN_K Expr semicol;
Statement ::= (Statement_Read       ) READ_K lparen Designator rparen semicol;
Statement ::= (Statement_Print      ) PRINT_K lparen Expr                        rparen semicol;
Statement ::= (Statement_PrintFormat) PRINT_K lparen Expr comma int_lit:MinWidth rparen semicol;
Statement ::= (Statement_Scope      ) lbrace StatementList rbrace;
Statement ::= (Statement_Semicolon  ) semicol;
Statement ::= (Statement_Err        ) error {: parser.report_error( "Bad statement", null ); :};

// action symbols for opening a new scope and the if-statement's jump instructions
IfCondition ::= (IfCondition_Plain) Condition;
IfStatement ::= (IfStatement_Plain) Statement;
ElseScope ::= (ElseScope_Plain) ELSE_K;
ElseStatement ::= (ElseStatement_Plain) Statement;

// action symbols for opening a new scope and the do-while-statement's jump instructions
DoWhileScope ::= (DoWhileScope_Plain) DO_K;
DoWhileCondition ::= (DoWhileCondition_Plain) DoWhileConditionScope Condition;
DoWhileConditionScope ::= (DoWhileConditionScope_Plain) ;

// action symbols for opening a new scope and the switch-statement's jump instructions
SwitchExpr ::= (SwitchExpr_Plain) Expr;

// ident.ident[ expr ] = expr
// ident.ident[ expr ]( )
// ident.ident[ expr ]( expr, expr, expr )
// ident.ident[ expr ]++
// ident.ident[ expr ]--
DesignatorStatement ::= (DesignatorStatement_Assign    ) Designator Assignop Expr;
DesignatorStatement ::= (DesignatorStatement_Call      ) MethodCall lparen ActPars rparen;
DesignatorStatement ::= (DesignatorStatement_Plusplus  ) Designator plusplus;
DesignatorStatement ::= (DesignatorStatement_Minusminus) Designator minusminus;

// <epsilon>
// statement statement statement statement
StatementList ::= (StatementList_Tail ) StatementList Statement;
StatementList ::= (StatementList_Empty) ;

// <epsilon>
// case 1: statement statement statement   case 2: statement statement
CaseList ::= (CaseList_Tail ) CaseList Case;
CaseList ::= (CaseList_Empty) ;

// case 1: statement statement statement
// case 2: 
// case 3: {}
Case ::= (Case_Plain) CaseScope StatementList;

// action symbols for opening a new scope and the case-statement's jump instructions
CaseScope ::= (CaseScope_Plain) CASE_K int_lit:CaseNum colon;



// <epsilon>
// expr
// expr, expr, expr
ActPars ::= (ActPars_Plain) ActParsScope ActParsList;
ActPars ::= (ActPars_Empty) ActParsScope ;

// action symbol for opening a new scope
ActParsScope ::= (ActParsScope_Plain) ;

// expr
// expr, expr, expr
ActParsList ::= (ActParsList_Expr)                   ActParam;
ActParsList ::= (ActParsList_Tail) ActParsList comma ActParam;

// expr
ActParam ::= (ActParam_Plain) Expr;

// expr   or   expr < expr and expr >= expr  or  expr != expr   // 'and' has greater priority than 'or'!
Condition ::= (Condition_Term)              CondTerm;
Condition ::= (Condition_Or  ) Condition or CondTerm;

// expr < expr and expr >= expr
CondTerm ::= (CondTerm_Fact)              CondFact;
CondTerm ::= (CondTerm_And ) CondTerm and CondFact;

// expr < expr and expr >= expr
CondFact ::= (CondFact_Expr ) Expr;
CondFact ::= (CondFact_Relop) Expr Relop Expr;

// +term - term + term + term
Expr ::= (Expr_Addition) Addition;
Expr ::= (Expr_Err     ) error {: parser.report_error( "Bad expression", null ); :};

// term
// +term
// -term
// term + term - term + term
// -term + term - term + term
// +term + term + term + term
Addition ::= (Addition_Term )                Term;
Addition ::= (Addition_STerm)          Addop Term;
Addition ::= (Addition_Tail ) Addition Addop Term;

// factor
// factor*factor*factor
Term ::= (Term_Factor)            Factor;
Term ::= (Term_Tail  ) Term Mulop Factor;



// ident.ident[ expr ]
// ident.ident[ expr ]( )
// ident.ident[ expr ]( expr, expr, expr )
// 1202 | 'c' | true
// new Object
// new Array[ expr ]
// ( expr )
Factor ::= (Factor_Designator ) Designator;
Factor ::= (Factor_MethodCall ) MethodCall lparen ActPars rparen;
Factor ::= (Factor_Literal    ) Literal;
Factor ::= (Factor_NewVar     ) NEW_K Type;
Factor ::= (Factor_NewArray   ) NEW_K Type lbracket Expr rbracket;
Factor ::= (Factor_Expr       ) lparen Expr rparen;

// ident.ident[ expr ]( expr, expr, expr )
MethodCall ::= (MethodCall_Plain) Designator;

// null
// ident
// ident.ident
// ident[ expr ]
// ident.ident.ident[ expr ].ident
// ident.ident.ident[ expr ].ident[ expr ]
Designator ::= (Designator_Ident  ) ident:Name;
Designator ::= (Designator_Null   ) NULL_K;
Designator ::= (Designator_Field  ) Designator dot ident:Name;
Designator ::= (Designator_ArrElem) Designator lbracket Expr rbracket;





// void | type
ReturnType ::= (ReturnType_Void ) VOID_K:TypeName;
ReturnType ::= (ReturnType_Ident) ident :TypeName;
// int | bool | char | ident
Type ::= (Type_Ident) ident:TypeName;
// 1202 | 'c' | true
Literal ::= (Literal_Int ) int_lit :Literal;
Literal ::= (Literal_Char) char_lit:Literal;
Literal ::= (Literal_Bool) bool_lit:Literal;

// =
Assignop ::= (Assignop_Assign) assign:Assignop;
// ==  |  !=  |  >  |  >=  |  <  |  <=
Relop ::= (Relop_Eq) eq:Relop;
Relop ::= (Relop_Ne) ne:Relop;
Relop ::= (Relop_Gt) gt:Relop;
Relop ::= (Relop_Ge) ge:Relop;
Relop ::= (Relop_Lt) lt:Relop;
Relop ::= (Relop_Le) le:Relop;
// +  |  -
Addop ::= (Addop_Plus ) plus :Addop;
Addop ::= (Addop_Minus) minus:Addop;
// *  |  /  |  %
Mulop ::= (Mulop_Mul ) mul :Mulop;
Mulop ::= (Mulop_Div ) div :Mulop;
Mulop ::= (Mulop_Perc) perc:Mulop;






