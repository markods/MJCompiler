// ________________________________________________________________________________________________
// import section
package rs.ac.bg.etf.pp1;

import java.util.ArrayList;
import org.apache.log4j.*;

import java_cup.runtime.*;
import rs.ac.bg.etf.pp1.ast.*;
import rs.ac.bg.etf.pp1.util.Log4JUtil;

// TODO: bolja prijava gresaka
// – definicija globalne promenljive – ignorisati karaktere do prvog znaka ";" ili sledećeg ","
// – konstrukcija iskaza dodele – ignorisati karaktere do ";"
// – deklaracija formalnog parametra funkcije – ignorisati znakove do znaka "," ili ")"
// – logički izraz unutar if konstrukcije - ignorisati karaktere do prvog znaka ")"
// – deklaracija polja unutrašnje klase – ignorisati karaktere do prvog ";" ili "{"
// – deklaracija proširenja natklase – ignorisati znakove do prvog znaka "{".


// ________________________________________________________________________________________________
// directive section

parser code {:
	protected static Logger logger = Logger.getLogger( Parser.class );
    
	private boolean errorDetected = false;
	private boolean fatalErrorDetected = false;

    private Symbol currSymbol = null;
    private ArrayList<Symbol> errorSymbols = new ArrayList<Symbol>();


    // check if there are parse errors
    public boolean hasErrors()     { return errorDetected || fatalErrorDetected; }
    public boolean hasFatalError() { return fatalErrorDetected; }


    @Override
    protected int error_sync_size() { return 1; }

    // NOTE: info is currently unused
    @Override
    public void report_fatal_error( String message, Object info )
    {
        fatalErrorDetected = true;

        report_error( message, info );
        done_parsing();
    }

    // NOTE: info is currently unused
    @Override
    public void report_error( String message, Object info )
    {
    	errorDetected = true;

        // ignore default messages (lr parser messages that can't be replaced without rewriting that part of the parser in the .jar file)
        if( message == null
        || "Syntax error".equals( message )
        || "Couldn't repair and continue parse".equals( message ) )
        {
            message = null;
        }

        // if a fatal error is detected and the message is null, set the default fatal error message
        if( fatalErrorDetected && message == null )
        {
            message = "Fatal error detected, parsing stopped";
        }

        int line = -1;
        int col  = -1;
        // prepare the error message
        {
            // if the error symbol list is empty, add the first error symbol to the error symbol list
            if( errorSymbols.size() == 0 ) errorSymbols.add( currSymbol );

            // if the message is not ready, don't report yet
            if( message == null ) return;
            
            // if the error is not fatal
            if( !fatalErrorDetected )
            {
                int lastIdx = errorSymbols.size() - 1;

                // remove the last n non-error symbols from the error symbols list
                // +   don't count ignored symbols while removing
                for( int i = 0; i < error_sync_size() + 1; i++ )
                {
                    // if the current symbol is an ignored symbol, include it in the removal
                    if( SymbolCode.ignore == errorSymbols.get( lastIdx ).sym )   i--;

                    // remove the last element from the list
                    errorSymbols.remove( lastIdx );
                    lastIdx--;
                }

                // remove the trailing whitespaces
                while( true )
                {
                    // if the current symbol is not an ignored symbol, break
                    if( SymbolCode.ignore != errorSymbols.get( lastIdx ).sym ) break;

                    // remove the last element from the list
                    errorSymbols.remove( lastIdx );
                    lastIdx--;
                }
            }

            Symbol firstSymbol = errorSymbols.get( 0 );
            line = firstSymbol.left;
            col  = firstSymbol.right;

            // build the error message
            StringBuilder messageBuilder = new StringBuilder( message ).append( "\n```" );
            for( int i = 0; i < errorSymbols.size(); i++ )
            {
                Symbol token = errorSymbols.get( i );
                messageBuilder.append( token.value );
            }
            messageBuilder.append( "```" );
            message = messageBuilder.toString();

            // clear all error symbols in the current syntax error
            errorSymbols.clear();
        }

        // report the syntax error
        Compiler.errorList().add( line, col, message, CompilerError.CompilerErrorType.SYNTAX_ERROR );
        Log4JUtil.logMultiline( logger::error, Compiler.errorList().getLast().toString() );
    }
    

    // this function is not designed for advanced error logging
    // +   ignore the <message> and current <symbol/ast node>
    @Override
    public void unrecovered_syntax_error( Symbol cur_token )
    {
        report_fatal_error( null, cur_token );
    }

    // this function is not designed for advanced error logging
    // +   ignore the <message> and current <symbol/ast node>
    @Override
    public void syntax_error( Symbol cur_token )
    {
        report_error( null, cur_token );
    }

:}

scan with {:
    while( true )
    {
        // replace the current symbol with the next symbol from the scanner
    	currSymbol = getScanner().next_token();

        // if the parser is currently resolving an error, save the symbol
        if( errorSymbols.size() > 0 )
        {
            errorSymbols.add( currSymbol );
        }

        // if the current symbol should not be ignored
        if( currSymbol.sym != SymbolCode.ignore )
        {
            // log the current symbol and break
            Log4JUtil.logMultiline( logger::info, SymbolCode.symbolToString( currSymbol ) );
            break;
        }
    }

    // return the current symbol
    return currSymbol;
:}





// ________________________________________________________________________________________________
// language characters


// keywords [terminals]
terminal PROGRAM_K, CLASS_K, /*ENUM_K,*/ EXTENDS_K;   // enum currently not used
terminal STATIC_K, CONST_K, VOID_K;
terminal IF_K, ELSE_K, SWITCH_K, CASE_K, BREAK_K, CONTINUE_K, RETURN_K;
terminal DO_K, WHILE_K;
terminal NEW_K, PRINT_K, READ_K;

// operators [terminals]
//       +     -      *    /    %
terminal plus, minus, mul, div, perc;
//       ==  !=  >   >=  <   <=  &&   ||
terminal eq, ne, gt, ge, lt, le, and, or;
//       =       ++        --
terminal assign, plusplus, minusminus;
//       ;        ,      .    {       }       (       )       [         ]         :
terminal semicol, comma, dot, lbrace, rbrace, lparen, rparen, lbracket, rbracket, colon;

// literals [terminals]
terminal Integer int_lit;      // 0   10   12012
terminal Boolean bool_lit;     // true   false
terminal Character char_lit;   // 'a'   '-'

// identifiers [terminals]
terminal String ident;         // asdf0_13

// newlines, whitespaces, comments [terminals]
// +   whitespace does not include newlines!
terminal ignore;               // // ... newline? | /* ... */
// error symbol in lexer [terminals]
// +   used instead of error, since then the parser doesn't skip reporting it as an error
terminal invalid;



// declarations [nonterminals]
nonterminal Program, GlobalDeclList, GlobalDecl;
nonterminal ClassDecl, ClassIdentDecl, ClassDeclScope, ClassVarDeclList, ClassVarDecl, MethodDeclScope, MethodDeclList;
nonterminal MethodDecl, FormPars, FormParsList, VarDeclList;
nonterminal VarDecl, VarIdentList;
nonterminal ConstDecl, IdentInitList;

// statement parts [nonterminals]
nonterminal Statement, DesignatorStatement;
nonterminal StatementList, CaseList, ActPars, ActParsList;
nonterminal Condition, CondTerm, CondFact;
nonterminal Expr, Addition, SignedAddition;
nonterminal Term, Factor;
nonterminal Designator, DesignatorNext;

// types, literals, operators [nonterminals]
nonterminal FormParam, IdentInit, VarIdent, Literal, ReturnType, Type;
nonterminal Assignop, Relop, Addop, Mulop;



// associativity [terminals]
precedence left ELSE_K;        // left associative operation => 'else' is paired with the closest left 'if'

// starting non-terminal
start with Program;





// ________________________________________________________________________________________________
// language rules


// program ident { }
// program ident { method method method }
// program ident constdl constdl vardl vardl classdl { }
// program ident constdl constdl vardl vardl classdl { method method method }
Program ::= (Program_Plain) PROGRAM_K ident GlobalDeclList MethodDeclScope;

// <epsilon>
// constdl constdl vardl vardl classdl
GlobalDeclList ::= (GlobalDeclList_Tail ) GlobalDecl GlobalDeclList;
GlobalDeclList ::= (GlobalDeclList_Empty) ;

GlobalDecl ::= (GlobalDecl_Const) ConstDecl;
GlobalDecl ::= (GlobalDecl_Var  ) VarDecl;
GlobalDecl ::= (GlobalDecl_Class) ClassDecl;



// class A { }
// class A { { method method method } }
// class A extends B { vardl vardl vardl vardl }
// class A extends B { vardl vardl vardl vardl { method method method } }
ClassDecl ::= (ClassDecl_Plain) ClassIdentDecl ClassDeclScope;

// class A
// class A extends B
ClassIdentDecl ::= (ClassIdentDecl_Plain  ) CLASS_K ident;
ClassIdentDecl ::= (ClassIdentDecl_Extends) CLASS_K ident EXTENDS_K Type;
ClassIdentDecl ::= (ClassIdentDecl_Err    ) CLASS_K error:e {: parser.report_error( "Invalid class identifier declaration", null ); :};

// { }
// { { method method method } }
// { vardl vardl vardl vardl }
// { vardl vardl vardl vardl { method method method } }
ClassDeclScope ::= (ClassDeclScope_Vars       ) lbrace ClassVarDeclList                 rbrace;
ClassDeclScope ::= (ClassDeclScope_VarsMethods) lbrace ClassVarDeclList MethodDeclScope rbrace;

// <epsilon>
// clsvardl clsvardl clsvardl clsvardl
ClassVarDeclList ::= (ClassVarDeclList_VarDecl) ClassVarDecl ClassVarDeclList;
ClassVarDeclList ::= (ClassVarDeclList_Empty  ) ;

// int a, b[], c;
// A a1, a2;
// static int a, b[], c;
// static A a1, a2;
ClassVarDecl ::= (ClassVarDecl_Plain )          Type VarIdentList semicol;
ClassVarDecl ::= (ClassVarDecl_Static) STATIC_K Type VarIdentList semicol;

// { }
// { method method method }
MethodDeclScope ::= (MethodDeclScope_Plain) lbrace MethodDeclList rbrace;

MethodDeclList ::= (MethodDeclList_Tail ) MethodDecl MethodDeclList;
MethodDeclList ::= (MethodDeclList_Empty) ;



// void foo() { }
// void foo() { statement statement }
// void foo() vardl vardl { }
// void foo() vardl vardl { statement statement }
// void foo( int a, char c, Node Array[] ) { }
// void foo( int a, char c, Node Array[] ) { statement statement }
// void foo( int a, char c, Node Array[] ) vardl vardl { }
// void foo( int a, char c, Node Array[] ) vardl vardl { statement statement }
MethodDecl ::= (MethodDecl_Plain) ReturnType ident lparen FormPars rparen VarDeclList lbrace StatementList rbrace;

// <epsilon>
// int ident, Node Array[], char c
FormPars ::= (FormPars_List ) FormParsList;
FormPars ::= (FormPars_Empty) ;

FormParsList ::= (FormParsList_Init) FormParam;
FormParsList ::= (FormParsList_Tail) FormParam comma FormParsList;

// <epsilon>
// vardl vardl vardl vardl
VarDeclList ::= (VarDeclList_VarDecl) VarDecl VarDeclList;
VarDeclList ::= (VarDeclList_Empty  ) ;



// int a, b[], c;
// A a1, a2;
VarDecl ::= (VarDecl_Plain) Type VarIdentList semicol;

VarIdentList ::= (VarIdentList_VarIdent) VarIdent;
VarIdentList ::= (VarIdentList_Tail    ) VarIdent comma VarIdentList;



// const int a = 5, b = 6, c = 11;
ConstDecl ::= (ConstDecl_Plain) CONST_K Type IdentInitList semicol;

IdentInitList ::= (IdentInitList_Init) IdentInit;
IdentInitList ::= (IdentInitList_Tail) IdentInit comma IdentInitList;



// ident.ident[ expr ] = expr;
// ident.ident[ expr ]( );
// ident.ident[ expr ]( expr, expr, expr );
// ident.ident[ expr ]++;
// ident.ident[ expr ]--;
//
// if( condition ) statement
// if( condition ) statement else statement
// do statement while( condition );
// switch( expr ) { }
// switch( expr ) { case 1: statement statement statement   case 2: statement statement }
// break;
// continue;
// return;
// return expr;
//
// read( ident.ident[ expr ] );
// print( ident.ident[ expr ], 2 );
//
// {}
// { statement statement statement }
Statement ::= (Statement_Designator ) DesignatorStatement semicol;
Statement ::= (Statement_If         ) IF_K lparen Condition rparen Statement;
Statement ::= (Statement_IfElse     ) IF_K lparen Condition rparen Statement ELSE_K Statement;
Statement ::= (Statement_DoWhile    ) DO_K Statement WHILE_K lparen Condition rparen semicol;
Statement ::= (Statement_Switch     ) SWITCH_K lparen Expr rparen lbrace CaseList rbrace;
Statement ::= (Statement_Break      ) BREAK_K semicol;
Statement ::= (Statement_Continue   ) CONTINUE_K semicol;
Statement ::= (Statement_Return     ) RETURN_K semicol;
Statement ::= (Statement_ReturnExpr ) RETURN_K Expr semicol;
Statement ::= (Statement_Read       ) READ_K lparen Designator rparen semicol;
Statement ::= (Statement_Print      ) PRINT_K lparen Expr rparen semicol;
Statement ::= (Statement_PrintFormat) PRINT_K lparen Expr comma int_lit rparen semicol;
Statement ::= (Statement_Scope      ) lbrace StatementList rbrace;
Statement ::= (Statement_Semicolon  ) semicol;
Statement ::= (Statement_Err        ) error:e semicol {: parser.report_error( "Invalid statement", null ); :};

// ident.ident[ expr ] = expr
// ident.ident[ expr ]( )
// ident.ident[ expr ]( expr, expr, expr )
// ident.ident[ expr ]++
// ident.ident[ expr ]--
DesignatorStatement ::= (DesignatorStatement_Assign    ) Designator Assignop Expr;
DesignatorStatement ::= (DesignatorStatement_Call      ) Designator lparen ActPars rparen;
DesignatorStatement ::= (DesignatorStatement_Plusplus  ) Designator plusplus;
DesignatorStatement ::= (DesignatorStatement_Minusminus) Designator minusminus;



// <epsilon>
// statement statement statement statement
StatementList ::= (StatementList_Tail ) Statement StatementList;
StatementList ::= (StatementList_Empty) ;

// <epsilon>
// case 1: statement statement statement   case 2: statement statement
CaseList ::= (CaseList_Tail ) CASE_K int_lit colon StatementList CaseList;
CaseList ::= (CaseList_Empty) ;

// <epsilon>
// expr
// expr, expr, expr
ActPars ::= (ActPars_Tail ) ActParsList;
ActPars ::= (ActPars_Empty) ;

ActParsList ::= (ActParsList_Expr) Expr;
ActParsList ::= (ActParsList_Tail) Expr comma ActParsList;

// expr   or   expr < expr and expr >= expr  or  expr != expr   // 'and' has greater priority than 'or'!
Condition ::= (Condition_Term) CondTerm;
Condition ::= (Condition_Tail) CondTerm or Condition;

CondTerm ::= (CondTerm_Fact) CondFact;
CondTerm ::= (CondTerm_Tail) CondFact and CondTerm;

CondFact ::= (CondFact_Expr) Expr;
CondFact ::= (CondFact_Tail) Expr Relop Expr;

// term
// +term
// -term
// term + term - term + term
// -term + term - term + term
// +term + term + term + term
Expr ::= (Expr_Addition) Addition;
Expr ::= (Expr_Err     ) error:e {: parser.report_error( "Invalid expression", null ); :};

Addition ::= (Addition_Term    ) Term;
Addition ::= (Addition_Tail    )      SignedAddition;
Addition ::= (Addition_TermTail) Term SignedAddition;

SignedAddition ::= (SignedAddition_Term) Addop Term;
SignedAddition ::= (SignedAddition_Tail) Addop Term SignedAddition;



// factor
// factor*factor*factor
Term ::= (Term_Factor) Factor;
Term ::= (Term_Tail  ) Factor Mulop Term;

// ident.ident[ expr ]
// ident.ident[ expr ]( )
// ident.ident[ expr ]( expr, expr, expr )
// 1202 | 'c' | true
// new Object
// new Array[ expr ]
// ( expr )
Factor ::= (Factor_Designator    ) Designator;
Factor ::= (Factor_DesignatorCall) Designator lparen ActPars rparen;
Factor ::= (Factor_Literal       ) Literal;
Factor ::= (Factor_NewVar        ) NEW_K Type;
Factor ::= (Factor_NewArray      ) NEW_K Type lbracket Expr rbracket;
Factor ::= (Factor_Expr          ) lparen Expr rparen;

// ident
// ident.ident
// ident[ expr ]
// ident.ident.ident[ expr ].ident
// ident.ident.ident[ expr ].ident[ expr ]
Designator ::= (Designator_Plain) ident DesignatorNext;

DesignatorNext ::= (DesignatorNext_FieldTail) dot ident              DesignatorNext;
DesignatorNext ::= (DesignatorNext_ElemTail ) lbracket Expr rbracket DesignatorNext;
DesignatorNext ::= (DesignatorNext_Empty    ) ;



// int ident
// Node Array[]
// char c
FormParam ::= Type VarIdent;
FormParam ::= error:e {: parser.report_error( "Invalid formal parameter", null ); :};
// ident = 12430
IdentInit ::= (IdentInit_Plain) ident Assignop Literal;
IdentInit ::= (IdentInit_Err  ) error:e {: parser.report_error( "Invalid identifier initialization", null ); :};
// ident | array[]
VarIdent ::= (VarIdent_Ident) ident;
VarIdent ::= (VarIdent_Array) ident lbracket rbracket;
VarIdent ::= (VarIdent_Err  ) error:e {: parser.report_error( "Invalid variable identifier", null ); :};

// 1202 | 'c' | true
Literal ::= (Literal_Int ) int_lit;
Literal ::= (Literal_Char) char_lit;
Literal ::= (Literal_Bool) bool_lit;
// void | type
ReturnType ::= (ReturnType_Void ) VOID_K;
ReturnType ::= (ReturnType_Ident) ident;
// int | bool | char | ident
Type ::= (Type_Ident) ident;
Type ::= (Type_Err  ) error:e {: parser.report_error( "Invalid type", null ); :};

// =
Assignop ::= (Assignop_Assign) assign;
// ==  |  !=  |  >  |  >=  |  <  |  <=
Relop ::= (Relop_Eq ) eq;
Relop ::= (Relop_Neq) ne;
Relop ::= (Relop_Gt ) gt;
Relop ::= (Relop_Geq) ge;
Relop ::= (Relop_Lt ) lt;
Relop ::= (Relop_Leq) le;
// +  |  -
Addop ::= (Addop_Plus ) plus;
Addop ::= (Addop_Minus) minus;
// *  |  /  |  %
Mulop ::= (Mulop_Mul ) mul;
Mulop ::= (Mulop_Div ) div;
Mulop ::= (Mulop_Perc) perc;






